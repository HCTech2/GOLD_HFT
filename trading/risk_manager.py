#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Gestionnaire de risque avec Circuit Breaker et protections avanc√©es
"""

import logging
import MetaTrader5 as mt5
from datetime import datetime, timedelta
from typing import Dict, List, Optional
from dataclasses import dataclass

from config.trading_config import TradingConfig, OrderType
from models.data_models import TradeRecord

logger = logging.getLogger(__name__)


@dataclass
class RiskLimits:
    """Limites de risque configurables"""
    max_daily_loss: float = 500.0  # Perte journali√®re maximale en $
    max_daily_trades: int = 50  # Nombre max de trades par jour
    max_consecutive_losses: int = 5  # Nombre max de pertes cons√©cutives
    max_drawdown_percent: float = 10.0  # Drawdown max en % du capital initial
    max_correlated_positions: int = 3  # Positions max dans la m√™me direction
    max_portfolio_risk_percent: float = 20.0  # Risque max du portefeuille en %
    cooldown_after_loss_streak_minutes: int = 30  # Pause apr√®s s√©rie de pertes


class RiskManager:
    """
    Gestionnaire de risque avec Circuit Breaker
    
    Protections:
    - Limite de pertes journali√®res
    - Limite de trades journaliers
    - D√©tection s√©rie de pertes cons√©cutives
    - Protection contre drawdown excessif
    - Limite positions corr√©l√©es
    - Cooldown automatique apr√®s pertes
    """
    
    def __init__(self, config: TradingConfig, limits: Optional[RiskLimits] = None):
        self.config = config
        self.limits = limits or RiskLimits()
        
        # √âtat du circuit breaker
        self.circuit_breaker_active = False
        self.circuit_breaker_reason = ""
        self.circuit_breaker_activated_at: Optional[datetime] = None
        
        # Statistiques journali√®res
        self.daily_pnl = 0.0
        self.daily_trades_count = 0
        self.daily_reset_time = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        
        # Statistiques de pertes
        self.consecutive_losses = 0
        self.last_loss_time: Optional[datetime] = None
        self.in_cooldown = False
        self.cooldown_until: Optional[datetime] = None
        
        # Capital initial
        self.initial_capital = config.initial_portfolio
        self.peak_capital = config.initial_portfolio
        
        logger.info("=" * 80)
        logger.info("üõ°Ô∏è RISK MANAGER INITIALIS√â")
        
        if not config.circuit_breaker_enabled:
            logger.warning("‚ö†Ô∏è CIRCUIT BREAKER D√âSACTIV√â - Aucune protection active")
        else:
            logger.info("‚úÖ Circuit Breaker ACTIV√â - Protections:")
            
            if config.risk_daily_loss_enabled:
                logger.info(f"   ‚úì Perte journali√®re: Max {self.limits.max_daily_loss}$")
            else:
                logger.info(f"   ‚úó Perte journali√®re: D√âSACTIV√âE")
            
            if config.risk_daily_trades_enabled:
                logger.info(f"   ‚úì Trades journaliers: Max {self.limits.max_daily_trades}")
            else:
                logger.info(f"   ‚úó Trades journaliers: D√âSACTIV√â")
            
            if config.risk_consecutive_losses_enabled:
                logger.info(f"   ‚úì Pertes cons√©cutives: Max {self.limits.max_consecutive_losses} (cooldown {self.limits.cooldown_after_loss_streak_minutes}min)")
            else:
                logger.info(f"   ‚úó Pertes cons√©cutives: D√âSACTIV√â")
            
            if config.risk_drawdown_enabled:
                logger.info(f"   ‚úì Drawdown: Max {self.limits.max_drawdown_percent}%")
            else:
                logger.info(f"   ‚úó Drawdown: D√âSACTIV√â")
            
            if config.risk_correlation_enabled:
                logger.info(f"   ‚úì Corr√©lation: Max {self.limits.max_correlated_positions} positions/direction")
            else:
                logger.info(f"   ‚úó Corr√©lation: D√âSACTIV√âE")
            
            if config.risk_portfolio_enabled:
                logger.info(f"   ‚úì Risque portefeuille: Max {self.limits.max_portfolio_risk_percent}%")
            else:
                logger.info(f"   ‚úó Risque portefeuille: D√âSACTIV√â")
        
        logger.info("=" * 80)
    
    def check_can_trade(self, order_type: OrderType, open_positions: List[TradeRecord]) -> tuple[bool, str]:
        """
        V√©rifie si un nouveau trade est autoris√©
        
        Returns:
            (can_trade, reason) - True si autoris√©, False sinon avec raison
        """
        
        # Si Circuit Breaker d√©sactiv√© globalement, autoriser
        if not self.config.circuit_breaker_enabled:
            return True, "‚úÖ Circuit Breaker d√©sactiv√©"
        
        # R√©initialiser les stats journali√®res si nouveau jour
        self._check_daily_reset()
        
        # 1. V√©rifier circuit breaker
        if self.circuit_breaker_active:
            return False, f"‚õî CIRCUIT BREAKER ACTIF: {self.circuit_breaker_reason}"
        
        # 2. V√©rifier cooldown apr√®s s√©rie de pertes (si activ√©)
        if self.config.risk_consecutive_losses_enabled and self.in_cooldown:
            if datetime.now() < self.cooldown_until:
                remaining = (self.cooldown_until - datetime.now()).total_seconds() / 60
                return False, f"üïê COOLDOWN ACTIF: {remaining:.1f} min restantes (s√©rie de {self.consecutive_losses} pertes)"
            else:
                # Sortir du cooldown
                self.in_cooldown = False
                self.cooldown_until = None
                logger.info("‚úÖ Fin du cooldown - Trading r√©activ√©")
        
        # 3. V√©rifier perte journali√®re (si activ√©)
        if self.config.risk_daily_loss_enabled:
            account_info = mt5.account_info()
            if account_info:
                daily_pnl = self._calculate_daily_pnl(account_info)
                
                if daily_pnl <= -self.limits.max_daily_loss:
                    self._activate_circuit_breaker(
                        f"Perte journali√®re {daily_pnl:.2f}$ atteinte (limite: -{self.limits.max_daily_loss}$)"
                    )
                    return False, f"‚õî PERTE JOURNALI√àRE LIMITE ATTEINTE: {daily_pnl:.2f}$"
        
        # 4. V√©rifier nombre de trades journaliers (si activ√©)
        if self.config.risk_daily_trades_enabled:
            if self.daily_trades_count >= self.limits.max_daily_trades:
                return False, f"üìä LIMITE TRADES JOURNALIERS ATTEINTE: {self.daily_trades_count}/{self.limits.max_daily_trades}"
        
        # 5. V√©rifier drawdown (si activ√©)
        if self.config.risk_drawdown_enabled:
            account_info = mt5.account_info()
            if account_info:
                current_capital = account_info.equity
                drawdown_percent = ((self.peak_capital - current_capital) / self.peak_capital) * 100
                
                if drawdown_percent > self.limits.max_drawdown_percent:
                    self._activate_circuit_breaker(
                        f"Drawdown {drawdown_percent:.1f}% d√©passe la limite {self.limits.max_drawdown_percent}%"
                    )
                    return False, f"‚õî DRAWDOWN EXCESSIF: {drawdown_percent:.1f}%"
                
                # Mettre √† jour le pic de capital
                if current_capital > self.peak_capital:
                    self.peak_capital = current_capital
        
        # 6. V√©rifier corr√©lation des positions (si activ√©)
        if self.config.risk_correlation_enabled:
            same_direction_count = sum(1 for pos in open_positions if pos.order_type == order_type)
            
            if same_direction_count >= self.limits.max_correlated_positions:
                return False, f"üîó TROP DE POSITIONS CORR√âL√âES: {same_direction_count} positions {order_type.name}"
        
        # 7. V√©rifier risque total du portefeuille (si activ√©)
        if self.config.risk_portfolio_enabled:
            account_info = mt5.account_info()
            if account_info:
                total_risk = self._calculate_total_portfolio_risk(open_positions, account_info)
                
                if total_risk > self.limits.max_portfolio_risk_percent:
                    return False, f"‚ö†Ô∏è RISQUE PORTEFEUILLE TROP √âLEV√â: {total_risk:.1f}%"
        
        # Tout est OK
        return True, "‚úÖ Conditions de trading respect√©es"
    
    def record_trade_opened(self, order_type: OrderType) -> None:
        """Enregistre l'ouverture d'un trade"""
        self.daily_trades_count += 1
        logger.debug(f"[RISK] Trade ouvert ({order_type.name}) - Total journalier: {self.daily_trades_count}")
    
    def record_trade_closed(self, trade: TradeRecord) -> None:
        """Enregistre la cl√¥ture d'un trade et met √† jour les statistiques"""
        
        profit = trade.profit if trade.profit is not None else 0.0
        self.daily_pnl += profit
        
        # G√©rer les pertes cons√©cutives (seulement si activ√©)
        if self.config.risk_consecutive_losses_enabled:
            if profit < 0:
                self.consecutive_losses += 1
                self.last_loss_time = datetime.now()
                
                logger.warning(f"[RISK] Perte enregistr√©e: {profit:.2f}$ - S√©rie: {self.consecutive_losses} pertes cons√©cutives")
                
                # Activer cooldown si trop de pertes
                if self.consecutive_losses >= self.limits.max_consecutive_losses:
                    self._activate_cooldown()
            else:
                # R√©initialiser le compteur de pertes
                if self.consecutive_losses > 0:
                    logger.info(f"[RISK] ‚úÖ Perte cons√©cutive r√©initialis√©e apr√®s gain de {profit:.2f}$")
                self.consecutive_losses = 0
        
        logger.debug(f"[RISK] P&L journalier: {self.daily_pnl:.2f}$ | Trades: {self.daily_trades_count}")
    
    def _activate_circuit_breaker(self, reason: str) -> None:
        """Active le circuit breaker"""
        self.circuit_breaker_active = True
        self.circuit_breaker_reason = reason
        self.circuit_breaker_activated_at = datetime.now()
        
        logger.critical("=" * 80)
        logger.critical("‚õî‚õî‚õî CIRCUIT BREAKER ACTIV√â ‚õî‚õî‚õî")
        logger.critical(f"Raison: {reason}")
        logger.critical(f"Heure: {self.circuit_breaker_activated_at.strftime('%Y-%m-%d %H:%M:%S')}")
        logger.critical("Trading automatiquement STOPP√â")
        logger.critical("=" * 80)
    
    def _activate_cooldown(self) -> None:
        """Active un cooldown apr√®s s√©rie de pertes"""
        self.in_cooldown = True
        self.cooldown_until = datetime.now() + timedelta(minutes=self.limits.cooldown_after_loss_streak_minutes)
        
        logger.warning("=" * 80)
        logger.warning(f"üïê COOLDOWN ACTIV√â: {self.consecutive_losses} pertes cons√©cutives")
        logger.warning(f"Trading suspendu jusqu'√† {self.cooldown_until.strftime('%H:%M:%S')}")
        logger.warning(f"Dur√©e: {self.limits.cooldown_after_loss_streak_minutes} minutes")
        logger.warning("=" * 80)
    
    def deactivate_circuit_breaker(self) -> None:
        """D√©sactive manuellement le circuit breaker"""
        if self.circuit_breaker_active:
            logger.warning("üîì Circuit Breaker d√©sactiv√© manuellement")
            self.circuit_breaker_active = False
            self.circuit_breaker_reason = ""
            self.circuit_breaker_activated_at = None
    
    def reset_daily_stats(self) -> None:
        """R√©initialise les statistiques journali√®res"""
        logger.info(f"[RISK] R√©initialisation stats journali√®res - P&L: {self.daily_pnl:.2f}$, Trades: {self.daily_trades_count}")
        self.daily_pnl = 0.0
        self.daily_trades_count = 0
        self.daily_reset_time = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
    
    def _check_daily_reset(self) -> None:
        """V√©rifie si on doit r√©initialiser les stats (nouveau jour)"""
        now = datetime.now()
        if now.date() > self.daily_reset_time.date():
            self.reset_daily_stats()
    
    def _calculate_daily_pnl(self, account_info) -> float:
        """Calcule le P&L journalier depuis MT5"""
        # R√©cup√©rer les deals du jour
        today_start = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
        deals = mt5.history_deals_get(today_start, datetime.now())
        
        if not deals:
            return 0.0
        
        daily_profit = sum(deal.profit for deal in deals if deal.magic == 234000)
        return daily_profit
    
    def _calculate_total_portfolio_risk(self, open_positions: List[TradeRecord], account_info) -> float:
        """Calcule le risque total du portefeuille en %"""
        if not open_positions:
            return 0.0
        
        total_risk = 0.0
        
        for pos in open_positions:
            # Calculer le risque par position (distance au SL * volume)
            risk_per_position = abs(pos.entry_price - pos.stop_loss) * pos.volume * 100
            total_risk += risk_per_position
        
        # Convertir en pourcentage du capital
        risk_percent = (total_risk / account_info.equity) * 100
        return risk_percent
    
    def get_risk_status(self) -> Dict:
        """Retourne l'√©tat actuel du gestionnaire de risque"""
        account_info = mt5.account_info()
        
        status = {
            'circuit_breaker_active': self.circuit_breaker_active,
            'circuit_breaker_reason': self.circuit_breaker_reason,
            'in_cooldown': self.in_cooldown,
            'cooldown_remaining_minutes': 0,
            'daily_pnl': self.daily_pnl,
            'daily_trades_count': self.daily_trades_count,
            'consecutive_losses': self.consecutive_losses,
            'current_drawdown_percent': 0.0,
            'can_trade': not self.circuit_breaker_active and not self.in_cooldown,
        }
        
        # Calculer temps restant du cooldown
        if self.in_cooldown and self.cooldown_until:
            remaining = (self.cooldown_until - datetime.now()).total_seconds() / 60
            status['cooldown_remaining_minutes'] = max(0, remaining)
        
        # Calculer drawdown actuel
        if account_info:
            current_capital = account_info.equity
            drawdown = ((self.peak_capital - current_capital) / self.peak_capital) * 100
            status['current_drawdown_percent'] = drawdown
        
        return status
    
    def get_risk_metrics(self) -> str:
        """Retourne les m√©triques de risque format√©es"""
        status = self.get_risk_status()
        
        lines = [
            "üõ°Ô∏è === M√âTRIQUES DE RISQUE ===",
            f"Circuit Breaker: {'‚õî ACTIF' if status['circuit_breaker_active'] else '‚úÖ Inactif'}",
        ]
        
        if status['circuit_breaker_active']:
            lines.append(f"   Raison: {status['circuit_breaker_reason']}")
        
        if status['in_cooldown']:
            lines.append(f"Cooldown: üïê ACTIF ({status['cooldown_remaining_minutes']:.1f} min restantes)")
        
        lines.extend([
            f"P&L Journalier: {status['daily_pnl']:.2f}$ (limite: -{self.limits.max_daily_loss}$)",
            f"Trades Journaliers: {status['daily_trades_count']}/{self.limits.max_daily_trades}",
            f"Pertes Cons√©cutives: {status['consecutive_losses']}/{self.limits.max_consecutive_losses}",
            f"Drawdown: {status['current_drawdown_percent']:.1f}% (max: {self.limits.max_drawdown_percent}%)",
            f"Statut Trading: {'‚úÖ AUTORIS√â' if status['can_trade'] else '‚õî BLOQU√â'}",
        ])
        
        return "\n".join(lines)
